{
  if (!recursion_guard_(builder_,level_,"userDefinableOperator"))   return false;
  if (!nextTokenIs(builder_,REM) && !nextTokenIs(builder_,AND) && !nextTokenIs(builder_,MUL)&& !nextTokenIs(builder_,PLUS)&& !nextTokenIs(builder_,MINUS)&& !nextTokenIs(builder_,DIV)&& !nextTokenIs(builder_,LT)&& !nextTokenIs(builder_,LT_LT)&& !nextTokenIs(builder_,LT_EQ)&& !nextTokenIs(builder_,EQ_EQ)&& !nextTokenIs(builder_,GT)&& !nextTokenIs(builder_,GT_EQ)&& !nextTokenIs(builder_,LBRACKET)&& !nextTokenIs(builder_,XOR)&& !nextTokenIs(builder_,NEGATE)&& !nextTokenIs(builder_,OR)&& !nextTokenIs(builder_,BIN_NOT)&& !nextTokenIs(builder_,INT_DIV)&& replaceVariants(builder_,18,"<user definable operator>"))   return false;
  boolean result_=false;
  Marker marker_=builder_.mark();
  enterErrorRecordingSection(builder_,level_,_SECTION_GENERAL_,"<user definable operator>");
  result_=multiplicativeOperator(builder_,level_ + 1);
  if (!result_)   result_=additiveOperator(builder_,level_ + 1);
  if (!result_)   result_=shiftOperator(builder_,level_ + 1);
  if (!result_)   result_=relationalOperator(builder_,level_ + 1);
  if (!result_)   result_=bitwiseOperator(builder_,level_ + 1);
  if (!result_)   result_=consumeToken(builder_,EQ_EQ);
  if (!result_)   result_=consumeToken(builder_,BIN_NOT);
  if (!result_)   result_=consumeToken(builder_,NEGATE);
  if (!result_)   result_=userDefinableOperator_8(builder_,level_ + 1);
  if (result_) {
    marker_.done(USER_DEFINABLE_OPERATOR);
  }
 else {
    marker_.rollbackTo();
  }
  result_=exitErrorRecordingSection(builder_,level_,result_,false,_SECTION_GENERAL_,null);
  return result_;
}
