{
  lastWrittenPosition=0;
  placedObjects=new TIntObjectHashMap<PlacedObject>();
  int spriteId=-1;
  analyze:   while (buffer.position() < buffer.limit()) {
    final int tagCodeAndLength=buffer.getShort();
    final int type=tagCodeAndLength >> 6;
    int length=tagCodeAndLength & 0x3F;
    if (length == 63) {
      length=buffer.getInt();
    }
    final int position=buffer.position();
switch (type) {
case TagTypes.End:
      break analyze;
case TagTypes.DefineShape:
case TagTypes.DefineShape2:
case TagTypes.DefineShape3:
case TagTypes.DefineShape4:
case TagTypes.DefineSprite:
    placedObjects.put(buffer.getShort(),new PlacedObject(position + 2,length,type));
  break;
case TagTypes.ExportAssets:
case TagTypes.SymbolClass:
spriteId=processExportAssetsOrSymbolClass();
if (spriteId == -1) {
break;
}
 else {
break analyze;
}
case TagTypes.FileAttributes:
buffer.put(buffer.position(),(byte)104);
fileAttributesEndPosition=position + length;
fileLength=fileAttributesEndPosition;
break;
}
buffer.position(position + length);
}
if (spriteId == -1) {
throw new IOException("Can't find symbol");
}
usedPlacedObjects=new ArrayList<PlacedObject>(placedObjects.size());
bounds=null;
processDefineSprite(placedObjects.get(spriteId));
usedPlacedObjects=null;
Collections.sort(usedPlacedObjects,new Comparator<PlacedObject>(){
@Override public int compare(PlacedObject o1,PlacedObject o2){
return o1.start < o2.start ? -1 : 1;
}
}
);
}
