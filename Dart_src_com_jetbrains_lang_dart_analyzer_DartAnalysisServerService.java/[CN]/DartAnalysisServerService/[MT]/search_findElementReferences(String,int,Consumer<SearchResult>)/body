{
  final String filePath=FileUtil.toSystemDependentName(_filePath);
  final String searchId;
synchronized (myLock) {
    if (myServer == null)     return;
    final AnalysisServer server=myServer;
    final Ref<String> searchIdRef=new Ref<String>();
    final Semaphore semaphore=new Semaphore();
    semaphore.down();
    server.search_findElementReferences(filePath,offset,true,new FindElementReferencesConsumer(){
      @Override public void computedElementReferences(      String searchId,      Element element){
        searchIdRef.set(searchId);
        semaphore.up();
      }
      @Override public void onError(      RequestError requestError){
        semaphore.up();
      }
    }
);
    final long t0=System.currentTimeMillis();
    semaphore.waitFor(FIND_ELEMENT_REFERENCES_TIMEOUT);
    if (semaphore.tryUp()) {
      LOG.info("search_findElementReferences() took too long for file " + filePath + "@"+ offset+ ": "+ (System.currentTimeMillis() - t0)+ "ms");
      return;
    }
    searchId=searchIdRef.get();
    if (searchId == null) {
      return;
    }
  }
  while (true) {
    ProgressManager.checkCanceled();
synchronized (mySearchResultSets) {
      SearchResultsSet resultSet;
      while ((resultSet=mySearchResultSets.poll()) != null) {
        if (!resultSet.id.equals(searchId))         continue;
        for (        final SearchResult searchResult : resultSet.results) {
          consumer.consume(searchResult);
        }
        if (resultSet.isLast)         return;
      }
      try {
        mySearchResultSets.wait();
      }
 catch (      InterruptedException e) {
        return;
      }
    }
  }
}
