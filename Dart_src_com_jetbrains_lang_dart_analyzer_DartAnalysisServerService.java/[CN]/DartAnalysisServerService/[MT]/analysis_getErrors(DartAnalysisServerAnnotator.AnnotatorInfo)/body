{
  final Ref<AnalysisError[]> resultRef=new Ref<AnalysisError[]>();
  final Semaphore semaphore=new Semaphore();
  try {
synchronized (myLock) {
      if (myServer == null)       return null;
      semaphore.down();
      final String path=FileUtil.toSystemDependentName(info.myFilePath);
      LOG.debug("analysis_getErrors(" + path + ")");
      myServer.analysis_getErrors(path,new GetErrorsConsumer(){
        @Override public void computedErrors(        final AnalysisError[] errors){
          if (semaphore.tryUp()) {
            resultRef.set(errors);
          }
 else {
            LOG.info("analysis_getErrors() took too long for file " + path + ", restarting daemon");
            ApplicationManager.getApplication().runReadAction(new Runnable(){
              @Override public void run(){
                final VirtualFile vFile=info.myProject.isDisposed() ? null : LocalFileSystem.getInstance().findFileByPath(info.myFilePath);
                final PsiFile psiFile=vFile == null ? null : PsiManager.getInstance(info.myProject).findFile(vFile);
                if (psiFile != null) {
                  DaemonCodeAnalyzer.getInstance(info.myProject).restart(psiFile);
                }
              }
            }
);
          }
        }
        @Override public void onError(        final RequestError error){
          LOG.error("Error from analysis_getErrors() for file " + path + ", SDK version = "+ mySdkVersion+ ", server version= "+ myServerVersion+ ", code="+ error.getCode()+ ": "+ error.getMessage());
          semaphore.up();
        }
      }
);
    }
    final long timeout=info.isLongerAnalysisTimeout() || ApplicationManager.getApplication().isUnitTestMode() ? GET_ERRORS_LONGER_TIMEOUT : GET_ERRORS_TIMEOUT;
    semaphore.waitFor(timeout);
  }
  finally {
    semaphore.up();
  }
  return resultRef.get();
}
