{
  final String messagePrefix="[" + module.getName() + "][Library "+ inputJar.getName()+ "] ";
  String sourceFileUrl=VfsUtil.pathToUrl(inputJar.getPath());
  Analyzer analyzer=new ReportingAnalyzer(compileContext,sourceFileUrl);
  analyzer.setPedantic(false);
  analyzer.setJar(inputJar);
  Jar dot=analyzer.getJar();
  analyzer.putAll(properties,false);
  if (analyzer.getProperty(Constants.IMPORT_PACKAGE) == null) {
    analyzer.setProperty(Constants.IMPORT_PACKAGE,"*;resolution:=optional");
  }
  if (analyzer.getProperty(Constants.BUNDLE_SYMBOLICNAME) == null) {
    Pattern p=Pattern.compile("(" + Verifier.SYMBOLICNAME.pattern() + ")(-[0-9])?.*\\.jar");
    String base=inputJar.getName();
    Matcher m=p.matcher(base);
    if (m.matches()) {
      base=m.group(1);
    }
 else {
      compileContext.addMessage(CompilerMessageCategory.ERROR,messagePrefix + "Can not calculate name of output bundle, rename jar or use -properties",sourceFileUrl,0,0);
      return false;
    }
    analyzer.setProperty(Constants.BUNDLE_SYMBOLICNAME,base);
  }
  if (analyzer.getProperty(Constants.EXPORT_PACKAGE) == null) {
    analyzer.setProperty(Constants.EXPORT_PACKAGE,"*");
  }
  analyzer.mergeManifest(dot.getManifest());
  String version=analyzer.getProperty(Constants.BUNDLE_VERSION);
  if (version != null) {
    version=Builder.cleanupVersion(version);
    analyzer.setProperty(Constants.BUNDLE_VERSION,version);
  }
  Manifest mf=analyzer.calcManifest();
  Jar jar=analyzer.getJar();
  final File f=FileUtil.createTempFile("tmpbnd",".jar");
  jar.write(f);
  jar.close();
  analyzer.close();
  if (outputJar.exists()) {
    if (!outputJar.delete()) {
      compileContext.addMessage(CompilerMessageCategory.ERROR,messagePrefix + "Could not delete outdated generated bundle. Is " + outputJar.getPath()+ " writable?",null,0,0);
      return false;
    }
  }
  final Ref<Boolean> result=new Ref<Boolean>(false);
  ApplicationManager.getApplication().invokeAndWait(new Runnable(){
    public void run(){
      result.set(ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>(){
        public Boolean compute(){
          if (!f.renameTo(outputJar)) {
            VirtualFile src=LocalFileSystem.getInstance().findFileByIoFile(f);
            if (src == null) {
              compileContext.addMessage(CompilerMessageCategory.ERROR,messagePrefix + "No jar file was created. This should not happen. Is " + f.getPath()+ " writable?",null,0,0);
              return false;
            }
            File parentFolder=outputJar.getParentFile();
            if (!parentFolder.exists()) {
              if (!parentFolder.mkdirs()) {
                compileContext.addMessage(CompilerMessageCategory.ERROR,messagePrefix + "Cannot create output folder. Is " + parentFolder.getPath()+ " writable?",null,0,0);
                return false;
              }
            }
            VirtualFile target=LocalFileSystem.getInstance().refreshAndFindFileByIoFile(parentFolder);
            if (target == null) {
              compileContext.addMessage(CompilerMessageCategory.ERROR,messagePrefix + "Output path " + parentFolder.getPath()+ " was created but cannot be found anymore. This should not happen.",null,0,0);
              return false;
            }
            try {
              VfsUtilCore.copyFile(this,src,target,outputJar.getName());
            }
 catch (            IOException e) {
              compileContext.addMessage(CompilerMessageCategory.ERROR,messagePrefix + "Could not copy " + src+ " to "+ target,null,0,0);
              return false;
            }
          }
          return true;
        }
      }
));
    }
  }
,ModalityState.defaultModalityState());
  return result.get();
}
