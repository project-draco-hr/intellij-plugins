{
  cleanupHolderCache();
  List<ManifestHolder> result=new ArrayList<ManifestHolder>();
  if (isLibraryDisposed(library) || project.isDisposed()) {
    return result;
  }
  VirtualFile[] classRoots=library.getFiles(OrderRootType.CLASSES);
  for (  VirtualFile classRoot : classRoots) {
    String jarFileUrl=classRoot.getUrl();
    ManifestHolder cachedHolder=myHolderCache.get(jarFileUrl);
    if (cachedHolder != null) {
      result.add(cachedHolder);
      continue;
    }
    VirtualFile classDir;
    if (classRoot.isDirectory()) {
      classDir=classRoot;
    }
 else {
      classDir=JarFileSystem.getInstance().getJarRootForLocalFile(classRoot);
    }
    if (classDir != null) {
      final VirtualFile manifestFile=classDir.findFileByRelativePath("META-INF/MANIFEST.MF");
      if (manifestFile != null) {
        final LibraryManifestHolderImpl newHolder=new LibraryManifestHolderImpl(library,project,jarFileUrl);
        Disposer.register(project,new Disposable(){
          @Override public void dispose(){
synchronized (LibraryManifestHolderImpl.class) {
              for (Iterator<LibraryManifestHolderImpl> iterator=myHolderCache.values().iterator(); iterator.hasNext(); ) {
                LibraryManifestHolderImpl holder=iterator.next();
                if (holder == newHolder) {
                  iterator.remove();
                  break;
                }
              }
            }
          }
        }
);
        myHolderCache.put(jarFileUrl,newHolder);
        result.add(newHolder);
      }
    }
  }
  return result;
}
