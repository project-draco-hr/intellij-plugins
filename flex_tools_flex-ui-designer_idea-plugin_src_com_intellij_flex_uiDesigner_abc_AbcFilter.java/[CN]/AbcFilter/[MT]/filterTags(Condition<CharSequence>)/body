{
  lastWrittenPosition=0;
  while (buffer.position() < buffer.limit()) {
    final int tagCodeAndLength=buffer.getShort();
    final int type=tagCodeAndLength >> 6;
    int length=tagCodeAndLength & 0x3F;
    if (length == 63) {
      length=buffer.getInt();
    }
switch (type) {
case TagTypes.End:
      buffer.position(lastWrittenPosition);
    channel.write(buffer);
  return;
case TagTypes.ShowFrame:
if (decoders.isEmpty()) {
  break;
}
 else {
  final int limit=buffer.position();
  writeDataBeforeTag(length);
  mergeDoAbc(true,false);
  lastWrittenPosition=limit - 2;
  buffer.position(limit + length);
  continue;
}
case TagTypes.SymbolClass:
processSymbolClass(length);
continue;
case TagTypes.ExportAssets:
processExportAssets(length);
continue;
case TagTypes.FileAttributes:
buffer.put(buffer.position(),(byte)104);
break;
case TagTypes.EnableDebugger:
case TagTypes.EnableDebugger2:
case TagTypes.SetBackgroundColor:
case TagTypes.ProductInfo:
case TagTypes.DebugID:
case TagTypes.ScriptLimits:
case TagTypes.Metadata:
skipTag(length);
continue;
case TagTypes.DoABC2:
readAbcName(buffer.position() + 4);
if (abcNameFilter != null && !abcNameFilter.value(transientNameString)) {
skipTag(length);
}
 else {
int oldPosition=buffer.position();
writeDataBeforeTag(length);
buffer.position(oldPosition);
doAbc2(length);
buffer.position(lastWrittenPosition);
}
continue;
}
buffer.position(buffer.position() + length);
}
}
