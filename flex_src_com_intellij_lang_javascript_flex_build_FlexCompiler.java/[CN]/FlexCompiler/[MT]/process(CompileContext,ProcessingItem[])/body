{
  final FlexCompilerHandler flexCompilerHandler=FlexCompilerHandler.getInstance(context.getProject());
  final FlexCompilerProjectConfiguration flexCompilerConfiguration=FlexCompilerProjectConfiguration.getInstance(context.getProject());
  if (!context.isMake()) {
    flexCompilerHandler.quitCompilerShell();
    for (    ProcessingItem item : items) {
      flexCompilerHandler.getCompilerDependenciesCache().markBCDirty(((MyProcessingItem)item).myModule,((MyProcessingItem)item).myBC);
    }
  }
  if (flexCompilerConfiguration.USE_FCSH) {
    context.addMessage(CompilerMessageCategory.INFORMATION,"FCSH tool is not supported yet. Please choose another compiler at File | Settings | Compiler | Flex Compiler",null,-1,-1);
    return ProcessingItem.EMPTY_ARRAY;
  }
 else {
    boolean builtIn=flexCompilerConfiguration.USE_BUILT_IN_COMPILER;
    final Sdk commonSdk=getSdkIfSame(items);
    if (builtIn && commonSdk == null) {
      builtIn=false;
      flexCompilerHandler.getBuiltInFlexCompilerHandler().stopCompilerProcess();
      context.addMessage(CompilerMessageCategory.INFORMATION,FlexBundle.message("can.not.use.built.in.compiler.shell"),null,-1,-1);
    }
    context.addMessage(CompilerMessageCategory.INFORMATION,FlexBundle.message(builtIn ? "using.builtin.compiler" : "using.mxmlc.compc",flexCompilerConfiguration.MAX_PARALLEL_COMPILATIONS),null,-1,-1);
    final Collection<FlexCompilationTask> compilationTasks=new ArrayList<FlexCompilationTask>();
    for (    final ProcessingItem item : items) {
      final Collection<FlexIdeBuildConfiguration> dependencies=new HashSet<FlexIdeBuildConfiguration>();
      final FlexIdeBuildConfiguration bc=((MyProcessingItem)item).myBC;
      for (      final DependencyEntry entry : bc.getDependencies().getEntries()) {
        if (entry instanceof BuildConfigurationEntry) {
          final FlexIdeBuildConfiguration dependencyBC=((BuildConfigurationEntry)entry).findBuildConfiguration();
          if (dependencyBC != null && !dependencyBC.isSkipCompile() && entry.getDependencyType().getLinkageType() != LinkageType.LoadInRuntime) {
            dependencies.add(dependencyBC);
          }
        }
      }
      compilationTasks.add(builtIn ? new BuiltInCompilationTask(((MyProcessingItem)item).myModule,bc,dependencies) : new MxmlcCompcCompilationTask(((MyProcessingItem)item).myModule,bc,dependencies));
      if (BCUtils.canHaveRuntimeStylesheets(bc)) {
        for (        String cssPath : bc.getCssFilesToCompile()) {
          final VirtualFile cssFile=LocalFileSystem.getInstance().findFileByPath(cssPath);
          if (cssFile == null)           continue;
          final ModifiableFlexIdeBuildConfiguration cssBC=Factory.getTemporaryCopyForCompilation(bc);
          cssBC.setMainClass(cssPath);
          cssBC.setOutputFileName(FileUtil.getNameWithoutExtension(PathUtil.getFileName(cssPath)) + ".swf");
          cssBC.setCssFilesToCompile(Collections.<String>emptyList());
          cssBC.getCompilerOptions().setResourceFilesMode(ResourceFilesMode.None);
          VirtualFile root=ProjectRootManager.getInstance(context.getProject()).getFileIndex().getSourceRootForFile(cssFile);
          if (root == null)           root=ProjectRootManager.getInstance(context.getProject()).getFileIndex().getContentRootForFile(cssFile);
          final String relativePath=root == null ? null : VfsUtilCore.getRelativePath(cssFile.getParent(),root,'/');
          if (!StringUtil.isEmpty(relativePath)) {
            final String outputFolder=PathUtil.getParentPath(bc.getActualOutputFilePath());
            cssBC.setOutputFolder(outputFolder + "/" + relativePath);
          }
          compilationTasks.add(builtIn ? new BuiltInCompilationTask(((MyProcessingItem)item).myModule,cssBC,dependencies) : new MxmlcCompcCompilationTask(((MyProcessingItem)item).myModule,cssBC,dependencies));
        }
      }
    }
    if (builtIn) {
      try {
        flexCompilerHandler.getBuiltInFlexCompilerHandler().startCompilerIfNeeded(commonSdk,context);
      }
 catch (      IOException e) {
        context.addMessage(CompilerMessageCategory.ERROR,e.toString(),null,-1,-1);
        return ProcessingItem.EMPTY_ARRAY;
      }
    }
    new FlexCompilationManager(context,compilationTasks).compile();
    final int activeCompilationsNumber=flexCompilerHandler.getBuiltInFlexCompilerHandler().getActiveCompilationsNumber();
    if (activeCompilationsNumber != 0) {
      LOG.error(activeCompilationsNumber + " Flex compilation(s) are not finished!");
    }
    FlexCompilerHandler.deleteTempFlexUnitFiles(context);
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      Function<CompilerMessage,String> toString=new Function<CompilerMessage,String>(){
        @Override public String fun(        final CompilerMessage compilerMessage){
          return compilerMessage.getMessage();
        }
      }
;
      StringBuilder s=new StringBuilder("Compiler errors:\n");
      s.append(StringUtil.join(context.getMessages(CompilerMessageCategory.ERROR),toString,"\n"));
      s.append("\nCompiler warnings:\n");
      s.append(StringUtil.join(context.getMessages(CompilerMessageCategory.WARNING),toString,"\n"));
      FlexCompilerHandler.getInstance(context.getProject()).setLastCompilationMessages(s.toString());
    }
    return items;
  }
}
