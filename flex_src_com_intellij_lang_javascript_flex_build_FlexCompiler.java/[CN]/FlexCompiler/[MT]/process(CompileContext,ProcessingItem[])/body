{
  final FlexCompilerHandler flexCompilerHandler=FlexCompilerHandler.getInstance(context.getProject());
  final FlexCompilerProjectConfiguration flexCompilerConfiguration=FlexCompilerProjectConfiguration.getInstance(context.getProject());
  if (flexCompilerConfiguration.USE_FCSH) {
    context.addMessage(CompilerMessageCategory.INFORMATION,"FCSH tool is not supported yet. Please choose another compiler at File | Settings | Compiler | Flex Compiler",null,-1,-1);
    return ProcessingItem.EMPTY_ARRAY;
  }
 else {
    boolean builtIn=flexCompilerConfiguration.USE_BUILT_IN_COMPILER;
    final Sdk commonSdk=getSdkIfSame(items);
    if (builtIn && commonSdk == null) {
      builtIn=false;
      flexCompilerHandler.getBuiltInFlexCompilerHandler().stopCompilerProcess();
      context.addMessage(CompilerMessageCategory.INFORMATION,FlexBundle.message("can.not.use.built.in.compiler.shell"),null,-1,-1);
    }
    context.addMessage(CompilerMessageCategory.INFORMATION,FlexBundle.message(builtIn ? "using.builtin.compiler" : "using.mxmlc.compc",flexCompilerConfiguration.MAX_PARALLEL_COMPILATIONS),null,-1,-1);
    final Collection<FlexCompilationTask> compilationTasks=new ArrayList<FlexCompilationTask>();
    for (    final ProcessingItem item : items) {
      final Collection<FlexIdeBuildConfiguration> dependencies=new HashSet<FlexIdeBuildConfiguration>();
      final FlexIdeBuildConfiguration bc=((MyProcessingItem)item).myBC;
      for (      final DependencyEntry entry : bc.getDependencies().getEntries()) {
        if (entry instanceof BuildConfigurationEntry) {
          final FlexIdeBuildConfiguration dependencyBC=((BuildConfigurationEntry)entry).findBuildConfiguration();
          if (dependencyBC != null && !dependencyBC.isSkipCompile() && entry.getDependencyType().getLinkageType() != LinkageType.LoadInRuntime) {
            dependencies.add(dependencyBC);
          }
        }
      }
      compilationTasks.add(builtIn ? new BuiltInCompilationTask(((MyProcessingItem)item).myModule,bc,dependencies) : new MxmlcCompcCompilationTask(((MyProcessingItem)item).myModule,bc,dependencies));
      if (BCUtils.canHaveRuntimeStylesheets(bc)) {
        for (        String cssPath : bc.getCssFilesToCompile()) {
          final VirtualFile cssFile=LocalFileSystem.getInstance().findFileByPath(cssPath);
          if (cssFile == null)           continue;
          final ModifiableFlexIdeBuildConfiguration cssBC=Factory.getTemporaryCopyForCompilation(bc);
          cssBC.setMainClass(cssPath);
          cssBC.setOutputFileName(FileUtil.getNameWithoutExtension(PathUtil.getFileName(cssPath)) + ".swf");
          cssBC.setCssFilesToCompile(Collections.<String>emptyList());
          cssBC.getCompilerOptions().setResourceFilesMode(CompilerOptions.ResourceFilesMode.None);
          VirtualFile root=ProjectRootManager.getInstance(context.getProject()).getFileIndex().getSourceRootForFile(cssFile);
          if (root == null)           root=ProjectRootManager.getInstance(context.getProject()).getFileIndex().getContentRootForFile(cssFile);
          final String relativePath=root == null ? null : VfsUtilCore.getRelativePath(cssFile.getParent(),root,'/');
          if (!StringUtil.isEmpty(relativePath)) {
            cssBC.setOutputFolder(cssBC.getOutputFolder() + "/" + relativePath);
          }
          compilationTasks.add(builtIn ? new BuiltInCompilationTask(((MyProcessingItem)item).myModule,cssBC,dependencies) : new MxmlcCompcCompilationTask(((MyProcessingItem)item).myModule,cssBC,dependencies));
        }
      }
    }
    if (builtIn) {
      try {
        flexCompilerHandler.getBuiltInFlexCompilerHandler().startCompilerIfNeeded(commonSdk,context);
      }
 catch (      IOException e) {
        context.addMessage(CompilerMessageCategory.ERROR,e.toString(),null,-1,-1);
        return ProcessingItem.EMPTY_ARRAY;
      }
    }
    new FlexCompilationManager(context,compilationTasks).compile();
    final int activeCompilationsNumber=flexCompilerHandler.getBuiltInFlexCompilerHandler().getActiveCompilationsNumber();
    if (activeCompilationsNumber != 0) {
      LOG.error(activeCompilationsNumber + " Flex compilation(s) are not finished!");
    }
    FlexCompilerHandler.deleteTempFlexUnitFiles(context);
    return items;
  }
}
