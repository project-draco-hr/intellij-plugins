{
  JSExpression methodExpr=newExpression.getMethodExpression();
  if (methodExpr != null) {
    if (methodExpr instanceof JSArrayLiteralExpression) {
      JSTypeSource source=JSTypeSourceFactory.createTypeSource(methodExpr);
      JSType type=JSNamedType.createType(VECTOR_CLASS_NAME,source,JSNamedType.StaticOrInstance.INSTANCE);
      PsiElement arrayInitializingType=newExpression.getArrayInitializingType();
      if (arrayInitializingType != null) {
        JSType argType=JSTypeUtils.createType(JSImportHandlingUtil.resolveTypeName(arrayInitializingType.getText(),newExpression),source);
        type=new JSGenericTypeImpl(source,type);
        ((JSGenericTypeImpl)type).addGenericArgument(argType);
      }
      addType(type,methodExpr);
    }
 else {
      String text=methodExpr.getText();
      JSResolveUtil.GenericSignature signature=JSResolveUtil.extractGenericSignature(text);
      if (signature != null) {
        text=signature.elementType;
      }
      if (methodExpr instanceof JSReferenceExpression && ((JSReferenceExpression)methodExpr).resolve() instanceof JSVariable) {
        text="*";
      }
 else {
        BaseJSSymbolProcessor.SimpleTypeProcessor subProcessor=new BaseJSSymbolProcessor.SimpleTypeProcessor();
        JSTypeEvaluator.evaluateTypes(methodExpr,myContext.targetFile,subProcessor);
        JSType type=subProcessor.getType();
        if (type != null && !(type instanceof JSAnyType) && JSTypeUtils.hasFunctionType(type)) {
          type=JSAnyType.get(methodExpr,false);
          text="*";
        }
        if (type != null && (!(type instanceof JSAnyType) || isNotValidType(text))) {
          text="Class".equals(type.getTypeText()) ? "*" : type.getTypeText();
        }
        if (!"*".equals(text)) {
          text=JSImportHandlingUtil.resolveTypeName(text,methodExpr);
        }
      }
      addType(JSTypeUtils.createType(text,JSTypeSourceFactory.createTypeSource(methodExpr,false)),methodExpr);
    }
  }
}
