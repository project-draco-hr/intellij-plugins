{
  final Iterator<FlexCompilationTask> iterator=myInProgressTasks.iterator();
  while (iterator.hasNext()) {
    FlexCompilationTask task=iterator.next();
    if (task.isFinished()) {
      iterator.remove();
      myFinishedTasks.add(task);
      if (task.isCompilationFailed()) {
        if (hasNotStartedDependentTasks(task)) {
          addMessage(task,CompilerMessageCategory.INFORMATION,FlexBundle.message("compilation.failed.dependent.will.be.skipped"),null,-1,-1);
          cancelNotStartedDependentTasks(task);
        }
 else {
          addMessage(task,CompilerMessageCategory.INFORMATION,FlexBundle.message("compilation.failed"),null,-1,-1);
        }
      }
 else {
        addMessage(task,CompilerMessageCategory.INFORMATION,FlexBundle.message("compilation.successfull"),null,-1,-1);
        final FlexIdeBuildConfiguration config=task.getFlexIdeConfig();
        if (config != null) {
          try {
            FlexCompilationUtils.performPostCompileActions(config);
          }
 catch (          FlexCompilerException e) {
            addMessage(task,CompilerMessageCategory.ERROR,e.getMessage(),e.getUrl(),e.getLine(),e.getColumn());
          }
        }
      }
      if (task.useCache()) {
        final Module module=task.getModule();
        if (task.isCompilationFailed()) {
          myCompilerDependenciesCache.markModuleAndDependentModulesDirty(module);
        }
 else         if (areAllModuleCompilationsSuccessful(module)) {
          final Collection<List<VirtualFile>> allConfigFiles=new ArrayList<List<VirtualFile>>();
          for (          final FlexCompilationTask t : myFinishedTasks) {
            if (!(t instanceof CssCompilationTask) && t.getModule().equals(module)) {
              allConfigFiles.add(t.getConfigFiles());
            }
          }
synchronized (this) {
            myCompilerDependenciesCache.cacheModuleWithDependencies(myCompileContext,module,allConfigFiles);
          }
        }
      }
    }
  }
}
