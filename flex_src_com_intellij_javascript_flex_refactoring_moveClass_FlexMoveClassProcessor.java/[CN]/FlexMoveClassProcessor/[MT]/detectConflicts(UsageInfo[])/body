{
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final Collection<PsiElement> filesToMove=Arrays.asList(myElementsToMove);
  for (  PsiElement file : filesToMove) {
    file.putUserData(JSVisibilityUtil.OVERRIDE_PACKAGE,myTargetPackage);
  }
  try {
    for (    UsageInfo usage : usages) {
      final PsiElement element=usage.getElement();
      if (!(element instanceof JSReferenceExpression)) {
        continue;
      }
      if (CommonRefactoringUtil.isAncestor(element,filesToMove)) {
        continue;
      }
      JSReferenceExpression refExpr=(JSReferenceExpression)element;
      final PsiElement resolved=refExpr.resolve();
      if (!(resolved instanceof JSQualifiedNamedElement)) {
        continue;
      }
      PsiElement containingClass=null;
      if (resolved instanceof JSFunction && ((JSFunction)resolved).isConstructor() && myElements.contains(containingClass=resolved.getParent()) || myElements.contains(resolved)) {
        JSRefactoringConflictsUtil.checkAccessibility((JSAttributeListOwner)resolved,(JSClass)containingClass,null,refExpr,conflicts,true);
      }
    }
    for (    PsiElement fileToMove : filesToMove) {
      JSRefactoringConflictsUtil.checkOutgoingReferencesAccessibility(fileToMove,filesToMove,null,true,conflicts,Conditions.<PsiElement>alwaysTrue());
    }
  }
  finally {
    for (    PsiElement file : filesToMove) {
      file.putUserData(JSVisibilityUtil.OVERRIDE_PACKAGE,null);
    }
  }
  return conflicts;
}
