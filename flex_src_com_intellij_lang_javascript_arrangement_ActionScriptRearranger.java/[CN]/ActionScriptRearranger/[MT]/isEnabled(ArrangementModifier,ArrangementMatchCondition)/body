{
  if (current == null) {
    return SUPPORTED_MODIFIERS.contains(modifier);
  }
  final Ref<ArrangementEntryType> typeRef=new Ref<ArrangementEntryType>();
  final Ref<Boolean> staticRef=new Ref<Boolean>(false);
  final Ref<Boolean> finalRef=new Ref<Boolean>(false);
  final Ref<Boolean> overrideRef=new Ref<Boolean>(false);
  current.invite(new ArrangementMatchConditionVisitor(){
    @Override public void visit(    @NotNull ArrangementAtomMatchCondition setting){
      if (setting.getType() == ArrangementSettingType.TYPE) {
        typeRef.set((ArrangementEntryType)setting.getValue());
      }
 else       if (setting.getValue() == STATIC) {
        staticRef.set(true);
      }
 else       if (setting.getValue() == FINAL) {
        finalRef.set(true);
      }
 else       if (setting.getValue() == OVERRIDE) {
        overrideRef.set(true);
      }
    }
    @Override public void visit(    @NotNull ArrangementCompositeMatchCondition setting){
      for (      ArrangementMatchCondition n : setting.getOperands()) {
        n.invite(this);
      }
    }
  }
);
  final ArrangementEntryType type=typeRef.get();
  if (type == null) {
    return true;
  }
switch (type) {
case STATIC_INIT:
    return false;
case CONST:
  return modifier == PUBLIC || modifier == PROTECTED || modifier == PACKAGE_PRIVATE || modifier == PRIVATE;
case VAR:
return modifier == STATIC || modifier == PUBLIC || modifier == PROTECTED || modifier == PACKAGE_PRIVATE || modifier == PRIVATE;
case CONSTRUCTOR:
return false;
case METHOD:
case PROPERTY:
case EVENT_HANDLER:
if (staticRef.get() && modifier == OVERRIDE) return false;
if (overrideRef.get() && modifier == STATIC) return false;
if (staticRef.get() && modifier == FINAL) return false;
if (finalRef.get() && modifier == STATIC) return false;
return true;
default :
LOG.error(type);
return true;
}
}
