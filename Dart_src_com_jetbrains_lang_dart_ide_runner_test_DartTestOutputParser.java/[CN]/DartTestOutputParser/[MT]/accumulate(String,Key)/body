{
  State currentState=myState, nextState=myState;
switch (currentState) {
case Init:
    if (text.startsWith(OBSERVATORY_MSG) && text.endsWith(NEWLINE)) {
      nextState=State.Timestamp;
      break;
    }
  break;
case Info:
break;
case Timestamp:
if (TIME_FORMAT.matcher(text.trim()).matches()) {
nextState=State.Pass;
}
break;
case Pass:
case Fail:
String contentCode=contentType.toString();
if (PASS_CODE.equals(contentCode)) {
if (text.equals(myPassCount)) {
nextState=State.Fail;
}
 else {
testFinished();
if (myFailCount == null) {
nextState=State.TestName;
}
 else {
nextState=State.Fail;
}
myPassCount=text;
}
}
 else if (FAIL_CODE.equals(contentCode)) {
if (text.equals(myFailCount)) {
nextState=State.TestName;
}
 else {
nextState=State.Error;
myFailCount=text;
}
}
if (text.startsWith(SOME_FAILED) || text.startsWith(ALL_PASSED)) {
nextState=State.End;
}
break;
case TestName:
nextState=State.Timestamp;
setTestName(text);
break;
case Error:
setTestName(text);
nextState=State.ErrorMessage;
break;
case ErrorMessage:
if (text.startsWith(CONTINUE_SPACES)) {
myFailureMessage+=text.substring(CONTINUE_SPACES.length());
}
 else {
testFailed();
myState=State.Timestamp;
return accumulate(text,contentType);
}
break;
case End:
return true;
}
myState=nextState;
return true;
}
