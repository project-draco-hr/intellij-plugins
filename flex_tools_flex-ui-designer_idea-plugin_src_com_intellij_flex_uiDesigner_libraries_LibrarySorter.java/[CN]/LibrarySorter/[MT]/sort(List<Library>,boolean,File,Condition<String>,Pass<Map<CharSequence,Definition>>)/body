{
  ArrayList<Library> resourceBundleOnlyItems=null;
  final THashMap<CharSequence,Definition> definitionMap=new THashMap<CharSequence,Definition>(libraries.size() * 128,AbcFilter.HASHING_STRATEGY);
  final List<LibrarySetItem> unsortedItems=collectItems(libraries,definitionMap,isExternal);
  final AbcMerger abcMerger=new AbcMerger(definitionMap,outFile);
  try {
    final ArrayList<Library> items=new ArrayList<Library>(unsortedItems.size());
    for (    LibrarySetItem item : unsortedItems) {
      if (!item.hasDefinitions()) {
        if (item.library.hasResourceBundles()) {
          if (resourceBundleOnlyItems == null) {
            resourceBundleOnlyItems=new ArrayList<Library>();
          }
          resourceBundleOnlyItems.add(item.library);
        }
        continue;
      }
      items.add(item.library);
      abcMerger.process(item.library);
    }
    if (definitionMapPostProcessor != null) {
      definitionMapPostProcessor.pass(definitionMap);
    }
    final List<Decoder> decoders=new ArrayList<Decoder>(definitionMap.size());
    final String[] singleStringArray=new String[1];
    definitionMap.forEachValue(new TObjectProcedure<Definition>(){
      @Override public boolean execute(      Definition definition){
        if (definition.doAbcData != null && (definition.resolved == ResolvedState.YES || (definition.resolved == ResolvedState.UNKNOWN && processDependencies(decoders,definition,definitionMap,singleStringArray)))) {
          decoders.add(new Decoder(definition.doAbcData));
          definition.doAbcData=null;
        }
        return true;
      }
    }
);
    final Encoder encoder=new Encoder();
    abcMerger.end(decoders,encoder);
    return new SortResult(definitionMap,items,resourceBundleOnlyItems);
  }
  finally {
    abcMerger.close();
  }
}
