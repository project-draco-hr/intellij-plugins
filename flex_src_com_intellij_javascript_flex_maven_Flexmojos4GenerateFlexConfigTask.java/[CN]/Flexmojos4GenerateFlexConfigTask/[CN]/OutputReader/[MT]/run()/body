{
  StringBuilder stringBuilder=null;
  int exitCode=-1;
  @SuppressWarnings("IOResourceOpenedButNotSafelyClosed") final InputStreamReader reader=new InputStreamReader(process.getInputStream());
  final List<String> filesForRefresh=new ArrayList<String>();
  try {
    stringBuilder=StringBuilderSpinAllocator.alloc();
    char[] buf=new char[64];
    int read;
    final Matcher matcher=RESULT_PATTERN.matcher(stringBuilder);
    while ((read=reader.read(buf,0,buf.length)) >= 0) {
      final int startForResultParse=stringBuilder.length();
      stringBuilder.append(buf,0,read);
      if (indicator.isCanceled()) {
        process.destroy();
      }
      if (matcher.find(startForResultParse)) {
        indicator.setText2(matcher.group(1));
        filesForRefresh.add(matcher.group(2));
      }
    }
    try {
      process.waitFor();
    }
 catch (    InterruptedException ignored) {
    }
    exitCode=process.exitValue();
  }
 catch (  IOException e) {
    if (stringBuilder != null) {
      LOG.warn(stringBuilder.toString(),e);
    }
  }
 finally {
    process.destroy();
    process=null;
    if (stringBuilder != null) {
      final String result=stringBuilder.toString();
      StringBuilderSpinAllocator.dispose(stringBuilder);
      if (exitCode != 0) {
        LOG.warn("Generating flex configs exited with exit code " + exitCode);
        showWarning(project);
      }
      LOG.info("Generating flex configs out:\n" + result);
    }
    final Matcher matcher=MAVEN_ERROR_PATTERN.matcher(stringBuilder);
    if (matcher.find()) {
      stringBuilder=StringBuilderSpinAllocator.alloc();
      try {
        do {
          stringBuilder.append("<br>").append(matcher.group(1));
        }
 while (matcher.find());
        showWarning(stringBuilder.toString(),project);
      }
  finally {
        StringBuilderSpinAllocator.dispose(stringBuilder);
      }
    }
    ApplicationManager.getApplication().invokeLater(new RefreshConfigFiles(filesForRefresh,FlexMojos4FacetImporter.getCompilerConfigsDir(project)));
  }
}
