{
  OsmorcFacetConfiguration conf=osmorcFacet.getConfiguration();
  if (conf.isDoNotSynchronizeWithMaven()) {
    return;
  }
  MavenId id=mavenProject.getMavenId();
  conf.setBundleSymbolicName(id.getGroupId() + "." + id.getArtifactId());
  String defaultVersion=ImporterUtil.cleanupVersion(id.getVersion());
  conf.setBundleVersion(defaultVersion);
  MavenPlugin plugin=mavenProject.findPlugin(myPluginGroupID,myPluginArtifactID);
  if (plugin == null) {
    return;
  }
  conf.setBundleSymbolicName(computeSymbolicName(mavenProject));
  conf.setBundleVersion(findConfigValue(mavenProject,"instructions." + Constants.BUNDLE_VERSION,defaultVersion));
  conf.setBundleActivator(findConfigValue(mavenProject,"instructions." + Constants.BUNDLE_ACTIVATOR));
  Map<String,String> props=ContainerUtil.newLinkedHashMap();
  Map<String,String> modelMap=mavenProject.getModelMap();
  String description=modelMap.get("description");
  if (!StringUtil.isEmptyOrSpaces(description)) {
    props.put(Constants.BUNDLE_DESCRIPTION,description);
  }
  String licenses=modelMap.get("licenses");
  if (!StringUtil.isEmptyOrSpaces(licenses)) {
    props.put("Bundle-License",licenses);
  }
  String vendor=modelMap.get("organization.name");
  if (!StringUtil.isEmpty(vendor)) {
    props.put(Constants.BUNDLE_VENDOR,vendor);
  }
  String docUrl=modelMap.get("organization.url");
  if (!StringUtil.isEmptyOrSpaces(docUrl)) {
    props.put(Constants.BUNDLE_DOCURL,docUrl);
  }
  Element instructionsNode=getConfig(mavenProject,"instructions");
  if (instructionsNode != null) {
    boolean useExistingManifest=false;
    for (    Element child : instructionsNode.getChildren()) {
      String name=child.getName();
      String value=child.getValue();
      if (INCLUDE_MANIFEST.equals(name)) {
        conf.setManifestLocation(value);
        conf.setManifestGenerationMode(OsmorcFacetConfiguration.ManifestGenerationMode.Manually);
        conf.setUseProjectDefaultManifestFileLocation(false);
        useExistingManifest=true;
      }
      if (StringUtil.startsWithChar(name,'_')) {
        name="-" + name.substring(1);
      }
      if (value != null) {
        value=value.replaceAll("\\p{Blank}*[\r\n]\\p{Blank}*","");
      }
      if (!StringUtil.isEmpty(value) && !INSTRUCTIONS_TO_SKIP.contains(name)) {
        props.put(name,value);
      }
    }
    if (!useExistingManifest) {
      conf.setManifestLocation("");
      conf.setManifestGenerationMode(OsmorcFacetConfiguration.ManifestGenerationMode.OsmorcControlled);
      conf.setUseProjectDefaultManifestFileLocation(true);
    }
    if (!props.containsKey(Constants.BUNDLE_NAME)) {
      props.put(Constants.BUNDLE_NAME,computeBundleName(mavenProject));
    }
  }
  ImporterUtil.postProcessAdditionalProperties(props,mavenProject);
  conf.importAdditionalProperties(props,true);
  String jarFileName=mavenProject.getFinalName() + ".jar";
switch (conf.getOutputPathType()) {
case OsgiOutputPath:
    conf.setJarFileLocation(jarFileName,OutputPathType.OsgiOutputPath);
  break;
case SpecificOutputPath:
String path=new File(conf.getJarFilePath(),jarFileName).getPath();
conf.setJarFileLocation(path,OutputPathType.SpecificOutputPath);
break;
default :
conf.setJarFileLocation(jarFileName,OutputPathType.CompilerOutputPath);
}
}
